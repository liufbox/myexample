# 数据库(mysql等关系类数据和Mongodb) CPU负载过高定位思路



CPU负载过高，根本原因是让CPU做的事情太多了，具体到关系型数据库和Mongodb，可能原因如下。

1.  索引相关的。

   查询结果需要排序，无对应索引，需要对全部查询结果集进行内存排序。可以考虑在相关需要排序的字段上建立索引，查询时按照对应索引获取结果，避免对结果集进行排序。 一般使用B树类索引，插入时的时间复杂度为O(mlogmn)，对应排序时间复杂度O(nlogn)，一般又是读多写少，数据库CPU负载会有显著降低。

   对只是整表扫描类的查询，一般磁盘IO负载会更高，查询线程大部分时间会处于等待，CPU负载反而很难上去。如果数据库内核使用类似epoll事件触发机制的，查询线程一般也不会阻塞。

2. 聚合等其他复杂计算过多。为数据库减负思路：增加更多计算节点 、 提前计算好结果（类似流式计算方式）和 分治思路。

   2.1 增加计算节点方式

   ​    2.1.1  增加更多只读备机，把读操作分配给备机，主机只用于写操作和及时性非常高的查询操作。

   ​    2.1.2  如果是使用存储和计算分离架构的分布式数据库，可以单纯增加计算节点，具体要看使用支持情况。

   ​    2.1.3  把聚合等复杂计算放到业务代码中，降低数据库的计算量。业务服务器一般可以低成本快速扩展。缺点：代码侵入性比较高，业务代码会较复杂。

   2.2 提前计算好结果

   ​	能够使用这个方式优化的前提是，f(n)= f(n，f(n-1))，可以直接使用f(n-1)结果和n进行计算获得f(n)。

      2.2.1 业务代码再写数据的时候，使用发MQ消息等方式异步计算结果。如果是实时性要求特别高的，可以考虑同步计算，不过代码可能比较难看。

      2.2.2 mysql通过监控blog、Mongodb通过监控oplog，发送变更消息到MQ，异步计算结果。mysql类数据库云厂商已经有比较成熟的方案。

   2.3 分治思路

      把大表拆成成多个小表。

      对排序类，

   

   

   

   



